{"version":3,"sources":["webpack://Pjax/webpack/bootstrap","webpack://Pjax/webpack/runtime/define property getters","webpack://Pjax/webpack/runtime/hasOwnProperty shorthand","webpack://Pjax/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://Pjax/./node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js","webpack://Pjax/./src/libs/LazyHistory/index.js","webpack://Pjax/./src/utils/Switches.js","webpack://Pjax/./src/utils/DefaultTrigger.js","webpack://Pjax/./src/switchDOM.js","webpack://Pjax/./src/utils/switchNodes.js","webpack://Pjax/./src/libs/executeScripts/Script.js","webpack://Pjax/./src/preparePage.js","webpack://Pjax/./src/libs/executeScripts/index.js","webpack://Pjax/./src/weakLoadURL.js","webpack://Pjax/./src/index.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","_defineProperty","value","configurable","writable","_classPrivateMethodGet","receiver","privateSet","fn","has","TypeError","window","sessionStorage","setItem","this","sessionKey","JSON","stringify","state","history","idPrefix","count","attached","historyKey","Switches","oldNode","newNode","innerHTML","textContent","oldEle","newEle","innerText","existingNames","getAttributeNames","forEach","target","setAttribute","getAttribute","filter","existing","removeAttribute","replaceWith","default","getLink","ele","checkingEle","links","document","includes","parent","parentElement","DefaultTrigger","constructor","pjax","onLinkOpen","event","link","defaultPrevented","MouseEvent","KeyboardEvent","metaKey","ctrlKey","shiftKey","altKey","origin","location","preventDefault","loadURL","href","catch","register","addEventListener","async","switchDOM","url","overrideOptions","selectors","switches","timeout","options","eventDetail","parsedURL","URL","targetURL","signal","abortController","request","Request","headers","timeoutID","setTimeout","abort","fire","response","fetch","finally","clearTimeout","newDocument","DOMParser","parseFromString","text","switchResult","sourceDocument","aborted","DOMException","focusCleared","switchesList","selector","sourceNodeList","querySelectorAll","targetNodeList","length","targetNode","index","activeElement","contains","blur","targetSwitch","switchPromise","Promise","resolve","then","push","outcomes","race","all","reject","switchNodes","newLocation","hash","pushState","title","preparePage","error","MIMETypes","focus","scripts","node","HTMLScriptElement","body","element","script","sort","a","b","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","scriptEleList","validScripts","map","scriptEle","evaluable","external","hasAttribute","typeString","type","trim","noModule","src","blocking","eval","createElement","onerror","name","defer","onload","head","appendChild","remove","blockingScripts","asyncScripts","evalScript","blockingPromise","reduce","promise","executeScripts","scrollTo","parsedScrollTo","Array","isArray","scrollX","hashId","decodeURIComponent","slice","getElementById","getElementsByName","scrollIntoView","weakLoadURL","storeScrollPosition","AbortController","pathname","search","pull","Pjax","reload","defaultTrigger","scrollRestoration","cacheMode","replaceState","parse","getItem","assign","scrollPos","scrollY","detail","CustomEvent","bubbles","cancelable","dispatchEvent","e"],"mappings":"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","file":"pjax.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return fn;\n}","/**\n * Lazy Session History API\n * ===\n * Access the associated data of a history entry even after user navigations.\n *\n * On page navigation events (like popstate), `window.history.state` has already been changed and\n * we can't update the previous state anymore. To leave a last mark on the leaving page, we have to\n * either keep updating the state continuously - which usually causes performance issues,\n * or make use of other API.\n *\n * Internally, this module uses **session storage** to store data, and uses browsers' original\n * history state as keys to identify session storage items.\n */\n\n/**\n * A valid state object.\n * @typedef {Object<string, any>} State\n */\n\nclass LazyHistory {\n  /**\n   * The prefix of the generated key.\n   * @type {string}\n   */\n  idPrefix;\n\n  /**\n   * Used to generate unique keys.\n   * @type {number}\n   */\n  count = 0;\n\n  /**\n   * The key used in `window.history.state`.\n   * @type {string}\n   */\n  historyKey;\n\n  /**\n   * The session key reflecting the current state.\n   * @type {string}\n   */\n  sessionKey;\n\n  /**\n   * The current state.\n   * @type {State}\n   */\n  state;\n\n  /**\n   * @param {string} idPrefix\n   * @param {string} historyKey\n   */\n  constructor(idPrefix, historyKey = idPrefix) {\n    this.idPrefix = idPrefix;\n    this.historyKey = historyKey;\n\n    // Initialize current history entry.\n    window.history.replaceState(this.#sign(), document.title);\n  }\n\n  /**\n   * Save current state to session storage.\n   */\n  #save() {\n    window.sessionStorage.setItem(this.sessionKey, JSON.stringify(this.state));\n  }\n\n  /**\n   * Prepare a new session key and attach to current or given state.\n   * @param {?State} state\n   * @return {State}\n   */\n  #sign(state = window.history.state) {\n    this.#save();\n\n    // Generate a new key.\n    const sessionKey = `${this.idPrefix}_${this.count}`;\n    this.count += 1;\n\n    // Generate attached state.\n    const attached = {\n      ...state || {},\n      [this.historyKey]: sessionKey,\n    };\n\n    this.sessionKey = sessionKey;\n    this.state = attached;\n\n    return attached;\n  }\n\n  /**\n   * Push to history entry.\n   * @param {?State} state\n   * @param {string} title\n   * @param {string} url\n   */\n  push(state, title, url) {\n    window.history.pushState(this.#sign(state), title, url);\n  }\n\n  /**\n   * Keep up with current browser history entry.\n   */\n  pull() {\n    this.#save();\n\n    const sessionKey = window.history.state?.[this.historyKey];\n    if (!sessionKey) {\n      // Initialize if haven't.\n      window.history.replaceState(this.#sign(), document.title);\n    } else {\n      this.sessionKey = sessionKey;\n      this.state = JSON.parse(window.sessionStorage.getItem(sessionKey));\n    }\n  }\n}\n\nexport default LazyHistory;\n","/**\n * @type {Readonly<Object<string, Pjax.Switch>>}\n */\nconst Switches = {\n  /**\n   * Replace HTML contents by using innerHTML.\n   * @param oldNode {Element}\n   * @param newNode {Element}\n   * @returns {Promise<void>}\n   */\n  async innerHTML(oldNode, newNode) {\n    // eslint-disable-next-line no-param-reassign\n    oldNode.innerHTML = newNode.innerHTML;\n  },\n\n  /**\n   * Replace all text by using textContent.\n   * @param oldNode {Node}\n   * @param newNode {Node}\n   * @returns {Promise<void>}\n   */\n  async textContent(oldNode, newNode) {\n    // eslint-disable-next-line no-param-reassign\n    oldNode.textContent = newNode.textContent;\n  },\n\n  /**\n   * Replace readable text by using innerText.\n   * @param oldEle {HTMLElement}\n   * @param newEle {HTMLElement}\n   * @returns {Promise<void>}\n   */\n  async innerText(oldEle, newEle) {\n    // eslint-disable-next-line no-param-reassign\n    oldEle.innerText = newEle.innerText;\n  },\n\n  /**\n   * Rewrite all attributes.\n   * @param oldEle {Element}\n   * @param newEle {Element}\n   * @returns {Promise<void>}\n   */\n  async attributes(oldEle, newEle) {\n    let existingNames = oldEle.getAttributeNames();\n    const targetNames = newEle.getAttributeNames();\n    targetNames.forEach((target) => {\n      oldEle.setAttribute(target, newEle.getAttribute(target));\n      existingNames = existingNames.filter((existing) => existing !== target);\n    });\n    existingNames.forEach((existing) => {\n      oldEle.removeAttribute(existing);\n    });\n  },\n\n  /**\n   * Replace the whole element by using replaceWith.\n   * @param oldNode {ChildNode}\n   * @param newNode {ChildNode}\n   * @returns {Promise<void>}\n   */\n  async replaceWith(oldNode, newNode) {\n    oldNode.replaceWith(newNode);\n  },\n};\n\nSwitches.default = Switches.replaceWith;\n\nexport default Switches;\n","/**\n * @typedef {HTMLAnchorElement|HTMLAreaElement} Link\n */\n\nconst getLink = (ele) => {\n  let checkingEle = ele;\n  const links = [...document.links];\n  while (!links.includes(checkingEle)) {\n    const parent = checkingEle.parentElement;\n    if (!parent) return null;\n    checkingEle = parent;\n  }\n  return checkingEle;\n};\n\nexport default class DefaultTrigger {\n  pjax;\n\n  /**\n   * @param {Pjax} pjax\n   */\n  constructor(pjax) {\n    this.pjax = pjax;\n  }\n\n  /**\n   * @param {Event} event\n   * @param {Link} link\n   */\n  onLinkOpen(event, link) {\n    if (event.defaultPrevented) return;\n\n    if (event instanceof MouseEvent || event instanceof KeyboardEvent) {\n      if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;\n    }\n\n    // External.\n    // loadURL checks external but without browsers' attribute related support.\n    if (link.origin !== window.location.origin) return;\n\n    event.preventDefault();\n\n    this.pjax.loadURL(link.href).catch(() => {});\n  }\n\n  register() {\n    document.addEventListener('click', (event) => {\n      const link = getLink(event.target);\n      if (!link) return;\n      this.onLinkOpen(event, link);\n    });\n    document.addEventListener('keyup', (event) => {\n      if (event.key !== 'Enter') return;\n      const link = getLink(event.target);\n      if (!link) return;\n      this.onLinkOpen(event, link);\n    });\n  }\n}\n","import switchNodes from './utils/switchNodes';\n\n/**\n * @this {Pjax}\n * @param {string} url\n * @param {Partial<Pjax.options>} [overrideOptions]\n * @return {Promise<void>}\n */\nexport default async function switchDOM(url, overrideOptions = {}) {\n  const { selectors, switches, timeout } = { ...this.options, ...overrideOptions };\n\n  const eventDetail = {};\n\n  const parsedURL = new URL(url, document.URL);\n  eventDetail.targetURL = parsedURL.href;\n\n  const signal = this.abortController?.signal || null;\n  eventDetail.signal = signal;\n\n  eventDetail.selectors = selectors;\n  const request = new Request(parsedURL.href, {\n    headers: {\n      'X-Requested-With': 'Fetch',\n      'X-Pjax': 'true',\n      'X-Pjax-Selectors': JSON.stringify(selectors),\n    },\n    signal,\n  });\n\n  // Set timeout\n  eventDetail.timeout = timeout;\n  let timeoutID = null;\n  if (timeout > 0) {\n    timeoutID = window.setTimeout(() => {\n      this.abortController?.abort();\n    }, timeout);\n    eventDetail.timeoutID = timeoutID;\n  }\n\n  this.fire('send', eventDetail);\n\n  try {\n    const response = await fetch(request)\n      .finally(() => {\n        window.clearTimeout(timeoutID);\n      });\n\n    // Switch before changing URL.\n    const newDocument = new DOMParser().parseFromString(await response.text(), 'text/html');\n    eventDetail.switches = switches;\n    const switchResult = await switchNodes(newDocument, { selectors, switches, signal });\n    eventDetail.switchResult = switchResult;\n\n    // Update window location. Preserve hash as the fetch discards it.\n    const newLocation = new URL(response.url);\n    newLocation.hash = parsedURL.hash;\n    if (window.location.href !== newLocation.href) {\n      window.history.pushState({}, document.title, newLocation.href);\n    }\n\n    // Simulate initial page load.\n    await this.preparePage(switchResult, overrideOptions);\n  } catch (error) {\n    eventDetail.error = error;\n    this.fire('error', eventDetail);\n    throw error;\n  } finally {\n    this.fire('complete', eventDetail);\n  }\n\n  this.fire('success', eventDetail);\n}\n","import Switches from './Switches';\n\n/**\n * @callback Pjax.Switch\n * @param {Node} oldNode\n * @param {Node} newNode\n * @return {Promise<any>|void}\n */\n\n/**\n * @typedef {Object} SwitchResult\n * @property {boolean} focusCleared\n * @property {Array<*>} outcomes\n */\n\n/**\n * @param {Document} sourceDocument\n * @param {Object} options\n * @param {Array<string>} options.selectors\n * @param {Object<string, Pjax.Switch>} [options.switches]\n * @param {AbortSignal} [options.signal]\n * @return {Promise<SwitchResult>}\n */\nexport default async function switchNodes(sourceDocument, {\n  selectors,\n  switches,\n  signal,\n}) {\n  if (signal?.aborted) throw new DOMException('Aborted switches', 'AbortError');\n\n  let focusCleared = false;\n  const switchesList = [];\n\n  selectors.forEach((selector) => {\n    const sourceNodeList = sourceDocument.querySelectorAll(selector);\n    const targetNodeList = document.querySelectorAll(selector);\n\n    // Throw when the structure is not match.\n    if (sourceNodeList.length !== targetNodeList.length) {\n      throw new DOMException(\n        `Selector '${selector}' does not select the same amount of nodes`,\n        'IndexSizeError',\n      );\n    }\n\n    // Start switching for each match.\n    targetNodeList.forEach((targetNode, index) => {\n      // Clear out focused controls before switching.\n      if (!focusCleared && document.activeElement && targetNode.contains(document.activeElement)) {\n        document.activeElement.blur();\n        focusCleared = true;\n      }\n\n      // Argument defined switch is prior to default switch.\n      const targetSwitch = switches?.[selector] || Switches.default;\n\n      // Start switching. Package to promise. Ignore switch errors.\n      const switchPromise = Promise.resolve()\n        .then(() => targetSwitch(targetNode, sourceNodeList[index]))\n        .catch(() => {});\n      switchesList.push(switchPromise);\n    });\n  });\n\n  // Reject as soon as possible on abort.\n  const outcomes = await Promise.race([\n    Promise.all(switchesList),\n    new Promise((resolve, reject) => {\n      signal?.addEventListener('abort', () => {\n        reject(new DOMException('Aborted switches', 'AbortError'));\n      });\n    }),\n  ]);\n\n  return {\n    focusCleared,\n    outcomes,\n  };\n}\n","/**\n * Follow\n * https://html.spec.whatwg.org/multipage/scripting.html#prepare-a-script\n * excluding steps concerning obsoleted attributes.\n */\n\n/**\n * JavaScript MIME type strings.\n */\nconst MIMETypes = [\n  'application/ecmascript',\n  'application/javascript',\n  'application/x-ecmascript',\n  'application/x-javascript',\n  'text/ecmascript',\n  'text/javascript',\n  'text/javascript1.0',\n  'text/javascript1.1',\n  'text/javascript1.2',\n  'text/javascript1.3',\n  'text/javascript1.4',\n  'text/javascript1.5',\n  'text/jscript',\n  'text/livescript',\n  'text/x-ecmascript',\n  'text/x-javascript',\n];\n\nclass Script {\n  constructor(scriptEle) {\n    this.evaluable = false;\n    this.external = false;\n\n    this.target = scriptEle;\n\n    // Process empty.\n    if (!scriptEle.hasAttribute('src') && !scriptEle.text) return;\n\n    // Process type.\n    const typeString = scriptEle.type ? scriptEle.type.trim() : 'text/javascript';\n    if (MIMETypes.includes(typeString)) {\n      this.type = 'classic';\n    } else if (typeString === 'module') {\n      this.type = 'module';\n    } else {\n      return;\n    }\n\n    // Process no module.\n    if (scriptEle.noModule && this.type === 'classic') {\n      return;\n    }\n\n    // Process external.\n    if (scriptEle.hasAttribute('src')) {\n      const src = scriptEle.getAttribute('src');\n\n      // An empty src attribute not results in external status\n      // and the script is not executable.\n      if (!src) return;\n\n      this.external = true;\n\n      try {\n        // eslint-disable-next-line no-new\n        new URL(src, document.URL);\n      } catch {\n        return;\n      }\n    }\n\n    // Process blocking.\n    this.blocking = true;\n    if (this.type !== 'classic') {\n      this.blocking = false;\n    } else if (this.external) {\n      if (scriptEle.hasAttribute('async')) {\n        this.blocking = false;\n      } else if (scriptEle.hasAttribute('defer')) {\n        this.blocking = false;\n      }\n    }\n\n    this.evaluable = true;\n  }\n\n  eval() {\n    return new Promise((resolve, reject) => {\n      const oldEle = this.target;\n      const newEle = document.createElement('script');\n\n      newEle.onerror = reject;\n\n      // Clone attributes and inner text.\n      oldEle.getAttributeNames().forEach((name) => {\n        newEle.setAttribute(name, oldEle.getAttribute(name));\n      });\n      newEle.text = oldEle.text;\n\n      if (this.external) {\n        // Reset async of external scripts to force synchronous loading.\n        // Needed since it defaults to true on dynamically injected scripts.\n        if (!newEle.hasAttribute('async')) newEle.async = false;\n\n        // Defer a dynamically inserted script is meaningless\n        // and may cause the script not to be executed in some environments.\n        newEle.defer = false;\n\n        newEle.onload = resolve;\n      }\n\n      // Execute.\n      if (document.contains(oldEle)) {\n        oldEle.replaceWith(newEle);\n      } else {\n        document.head.appendChild(newEle);\n        newEle.remove();\n      }\n\n      if (!this.external) resolve();\n    });\n  }\n}\n\nexport default Script;\n","import executeScripts from './libs/executeScripts';\n\n/**\n * After page elements are updated.\n * @this {Pjax}\n * @param {?SwitchResult} switchResult\n * @param {Partial<Pjax.options>} [overrideOptions]\n * @return {Promise<void>}\n */\nexport default async function preparePage(switchResult, overrideOptions = {}) {\n  const options = { ...this.options, ...overrideOptions };\n\n  // If page elements are switched.\n  if (switchResult) {\n    // Focus the FIRST autofocus if the previous focus is cleared.\n    // https://html.spec.whatwg.org/multipage/interaction.html#the-autofocus-attribute\n    if (switchResult.focusCleared) {\n      document.querySelectorAll('[autofocus]')[0]?.focus();\n    }\n\n    // List newly added and labeled scripts\n    const scripts = [...document.querySelectorAll(options.scripts)]\n      .filter((node) => node instanceof HTMLScriptElement);\n    options.selectors.forEach((selector) => {\n      document.body.querySelectorAll(selector).forEach((element) => {\n        element.querySelectorAll('script').forEach((script) => {\n          if (scripts.includes(script)) return;\n          scripts.push(script);\n        });\n      });\n    });\n\n    // Sort by document position.\n    // https://stackoverflow.com/a/22613028\n    scripts.sort((a, b) => (\n      // Bitwise AND operator is required here.\n      // eslint-disable-next-line no-bitwise\n      a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_PRECEDING || -1\n    ));\n\n    // Execute.\n    await executeScripts(scripts, { signal: this.abortController?.signal });\n  }\n\n  // Parse required scroll position.\n  const { scrollTo } = options;\n\n  // When scroll is allowed.\n  if (scrollTo !== false) {\n    // If switched, default to left top. Otherwise, default to no scroll.\n    let parsedScrollTo = switchResult ? [0, 0] : false;\n\n    if (Array.isArray(scrollTo)) {\n      parsedScrollTo = scrollTo;\n    } else if (typeof scrollTo === 'number') {\n      parsedScrollTo = [window.scrollX, scrollTo];\n    } else {\n      // Parse target.\n      const hashId = decodeURIComponent(window.location.hash.slice(1));\n\n      if (hashId) {\n        const target = document.getElementById(hashId) || document.getElementsByName(hashId)[0];\n        if (target) {\n          target.scrollIntoView();\n          parsedScrollTo = false;\n        }\n      }\n    }\n\n    // Scroll.\n    if (parsedScrollTo) window.scrollTo(parsedScrollTo[0], parsedScrollTo[1]);\n  }\n}\n","import Script from './Script';\n\n/**\n * Find and execute scripts in order.\n * Needed since innerHTML does not run scripts.\n * @param {Iterable<HTMLScriptElement>} scriptEleList\n * @param {Object} [options]\n * @param {AbortSignal} [options.signal]\n */\nexport default async function executeScripts(scriptEleList, { signal } = {}) {\n  if (signal?.aborted) throw new DOMException('Aborted execution', 'AbortError');\n\n  const validScripts = [...scriptEleList]\n    .map((scriptEle) => new Script(scriptEle))\n    .filter((script) => script.evaluable);\n\n  const blockingScripts = [];\n  const asyncScripts = [];\n  validScripts.forEach((script) => {\n    (script.blocking ? blockingScripts : asyncScripts).push(script);\n  });\n\n  // Evaluate script. Throw only when aborted.\n  const evalScript = async (script) => {\n    if (signal?.aborted) return;\n    await script.eval().catch(() => {});\n  };\n\n  // Evaluate external blocking scripts first\n  // to help browsers fetch them in parallel.\n  // Each inline blocking script will be evaluated as soon as\n  // all its previous blocking scripts are executed.\n  const blockingPromise = blockingScripts.reduce((promise, script) => {\n    if (script.external) {\n      return Promise.all([promise, evalScript(script)]);\n    }\n    return promise.then(() => evalScript(script));\n  }, Promise.resolve());\n\n  // Reject as soon as possible on abort.\n  return Promise.race([\n    Promise.all([\n      blockingPromise,\n      ...asyncScripts.map(evalScript),\n    ]),\n    new Promise((resolve, reject) => {\n      signal?.addEventListener('abort', () => {\n        reject(new DOMException('Aborted execution', 'AbortError'));\n      });\n    }),\n  ]);\n}\n","/**\n * Load a URL in Pjax way. Throw all errors.\n * @this {Pjax}\n * @param {string} url\n * @param {Partial<Pjax.options>} [overrideOptions]\n * @return {Promise<void>}\n */\nexport default async function weakLoadURL(url, overrideOptions = {}) {\n  const parsedURL = new URL(url, document.URL);\n\n  // External URL.\n  if (parsedURL.origin !== window.location.origin) {\n    throw new DOMException('Not same origin', 'SecurityError');\n  }\n\n  // Store scroll position.\n  this.storeScrollPosition();\n\n  // Setup abort controller.\n  const abortController = new AbortController();\n  this.abortController?.abort();\n  this.abortController = abortController;\n\n  // Find path difference.\n  const targetPath = parsedURL.pathname + parsedURL.search;\n  const currentPath = this.location.pathname + this.location.search;\n\n  if (targetPath === currentPath) {\n    // Directly pushState on same path.\n    if (window.location.href !== parsedURL.href) {\n      window.history.pushState({}, document.title, parsedURL.href);\n    }\n    await this.preparePage(null, overrideOptions);\n  } else {\n    // Fetch and switch on different path.\n    await this.switchDOM(url, overrideOptions);\n  }\n\n  // Update Pjax location and prepare the page.\n  this.history.pull();\n  this.location.href = window.location.href;\n\n  // Finish, remove abort controller.\n  this.abortController = null;\n}\n","import LazyHistory from './libs/LazyHistory';\n\nimport Switches from './utils/Switches';\nimport DefaultTrigger from './utils/DefaultTrigger';\n\nimport switchDOM from './switchDOM';\nimport preparePage from './preparePage';\nimport weakLoadURL from './weakLoadURL';\n\nclass Pjax {\n  static switches = Switches;\n\n  static reload() {\n    window.location.reload();\n  }\n\n  /**\n   * Pjax options.\n   * @property {boolean} defaultTrigger\n   * @property {Array<string>} selectors\n   * @property {Object<string, Pjax.Switch>} switches\n   * @property {string} scripts\n   * @property {number | number[] | boolean} scrollTo\n   * @property {boolean} scrollRestoration\n   * @property {RequestCache} cacheMode\n   * @property {number} timeout\n   */\n  options = {\n    defaultTrigger: true,\n    selectors: ['title', '.pjax'],\n    switches: {},\n    scripts: 'script[data-pjax]',\n    scrollTo: true,\n    scrollRestoration: true,\n    cacheMode: 'default',\n    timeout: 0,\n  };\n\n  history = new LazyHistory('pjax');\n\n  location = new URL(window.location.href);\n\n  /**\n   * Pjax navigation abort controller.\n   * @type {?AbortController}\n   */\n  abortController = null;\n\n  /**\n   * @param {Partial<Pjax.options>} options\n   */\n  constructor(options = {}) {\n    Object.assign(this.options, options);\n\n    if (this.options.scrollRestoration) {\n      window.history.scrollRestoration = 'manual';\n\n      // Browsers' own restoration is faster and more stable on reload.\n      window.addEventListener('beforeunload', () => {\n        window.history.scrollRestoration = 'auto';\n      });\n    }\n\n    if (this.options.defaultTrigger) new DefaultTrigger(this).register();\n\n    window.addEventListener('popstate', (event) => {\n      /**\n       * The main reason why we write the LazyHistory library is right here:\n       * `window.history.state` is ALREADY changed on popstate events and\n       * we can't update the previous state anymore. (For scroll position, etc.)\n       * As continuously updating `window.history.state` causes performance issues,\n       * using a custom library seems to be the only choice.\n       */\n\n      // Store scroll position and then update the lazy state.\n      this.storeScrollPosition();\n      this.history.pull();\n\n      // hashchange events trigger popstate with a null `event.state`.\n      if (event.state === null) return;\n\n      const overrideOptions = {};\n      if (this.options.scrollRestoration && 'scrollPos' in this.history.state) {\n        overrideOptions.scrollTo = this.history.state.scrollPos;\n      }\n\n      this.loadURL(window.location.href, overrideOptions).catch(() => {});\n    });\n  }\n\n  storeScrollPosition() {\n    this.history.state.scrollPos = [window.scrollX, window.scrollY];\n  }\n\n  /**\n   * Fire Pjax related events.\n   * @param {'send'|'error'|'success'|'complete'} type\n   * @param {Object} detail\n   */\n  fire(type, detail) {\n    const event = new CustomEvent(`pjax:${type}`, {\n      bubbles: true,\n      cancelable: false,\n      detail: {\n        abortController: this.abortController,\n        ...detail,\n      },\n    });\n    document.dispatchEvent(event);\n  }\n\n  switchDOM = switchDOM;\n\n  preparePage = preparePage;\n\n  weakLoadURL = weakLoadURL;\n\n  /**\n   * Load a URL in Pjax way. Navigate normally on errors except AbortError.\n   * @param {string} url\n   * @param {Partial<Pjax.options>} [overrideOptions]\n   * @return {Promise<void>}\n   */\n  async loadURL(url, overrideOptions = {}) {\n    try {\n      await this.weakLoadURL(url, overrideOptions);\n    } catch (e) {\n      if (e.name === 'AbortError') throw e;\n      window.location.assign(url);\n    }\n  }\n}\n\nexport default Pjax;\n"],"sourceRoot":""}